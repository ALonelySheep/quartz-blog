<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Regularization on</title><link>https://alonelysheep.github.io/quartz-blog/tags/Regularization/</link><description>Recent content in Regularization on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 05 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://alonelysheep.github.io/quartz-blog/tags/Regularization/index.xml" rel="self" type="application/rss+xml"/><item><title>D2L-44-Batch_Normalization-批量归一化</title><link>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.3/D2L-44-Batch_Normalization-%E6%89%B9%E9%87%8F%E5%BD%92%E4%B8%80%E5%8C%96/</link><pubDate>Sat, 05 Mar 2022 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.3/D2L-44-Batch_Normalization-%E6%89%B9%E9%87%8F%E5%BD%92%E4%B8%80%E5%8C%96/</guid><description>Batch Normalization 2022-03-05 Tags: #BatchNormalization #Normalization #DeepLearning #Regularization
批量归一化是一种加速收敛的方法.
批量归一化作用于每一个mini-Batch, 先将这个Batch归一化, 然后再做一个统一的偏移与拉伸.
最后这个偏移和拉伸的量是一个可以学习的超参数 对于全连接层, BN作用于每一个特征</description></item><item><title>D2L-23-Dropout-丢弃法</title><link>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.2/D2L-23-Dropout-%E4%B8%A2%E5%BC%83%E6%B3%95/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.2/D2L-23-Dropout-%E4%B8%A2%E5%BC%83%E6%B3%95/</guid><description>Dropout - 丢弃法(暂退法) 2022-02-14 Tags: #Dropout #Regularization #DeepLearning
1
Dropout就是在前向传播过程计算每一内部层的同时注入噪声, 从而提高模型的平滑性, 减少过拟合. 实现方式 实现的关键是要以一种无偏(不改变期望)的方式注入噪声.</description></item><item><title>Norm in Regularization - Intuition</title><link>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.2/Norm-in-Regularization-Intuition/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.2/Norm-in-Regularization-Intuition/</guid><description>Norm in Regularization - Intuition 2022-02-14 Tags: #Norm #Regularization #DeepLearning #MachineLearning
L2 Norm $\ell_{2}$ in Regularization L2 Norm 的等高线是圆形的</description></item><item><title>Regularization-正则化</title><link>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.2/Regularization-%E6%AD%A3%E5%88%99%E5%8C%96/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.2/Regularization-%E6%AD%A3%E5%88%99%E5%8C%96/</guid><description>Regularization 2022-02-14 Tags: #Regularization #DeepLearning
Definition Regularization: any modification we make to a learning algorithm that is intended to reduce its generalization error but not its training error.</description></item><item><title>D2L-22-权重衰减</title><link>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.2/D2L-22-%E6%9D%83%E9%87%8D%E8%A1%B0%E5%87%8F/</link><pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.2/D2L-22-%E6%9D%83%E9%87%8D%E8%A1%B0%E5%87%8F/</guid><description>权重衰减 2022-02-12 Tags: #Regularization #DeepLearning
权重衰减就是利用 $\ell_{2}$ 范数进行 正则化, 避免过拟合 权重衰减是通过减小目标参数(weights)的大小来实现正则化的, 这也是其名称的由来. 参数的范数代表了一种有用的简单性度量。1 Links:</description></item><item><title>Part.20_Regularized_Logistic_Regression(ML_Andrew.Ng.)</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.9/Part.20_Regularized_Logistic_RegressionML_Andrew.Ng./</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.9/Part.20_Regularized_Logistic_RegressionML_Andrew.Ng./</guid><description>Regularized Logistic Regression 2021-09-11 Tags: #MachineLearning #LogisticRegression #Regularization
回顾一下没有正则化的情况 损失函数 更简洁的形式 $$\begin{align} J(\theta) &amp;amp;=-\frac{1}{m} \sum_{i=1}^{m}\left[y^{(i)} \log \left(h_{\theta}\left(x^{(i)}\right)\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]\ \end{align}$$ or 向量化的 $$\begin{aligned} h&amp;amp;=g(X \theta) \ J(\theta)&amp;amp;=-\frac{1}{m} \cdot\left[y^{T} \log (h)+(1-y)^{T} \log (1-h)\right] \end{aligned}$$</description></item><item><title>正则项不影响Logistic回归损失函数凸性</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.9/%E6%AD%A3%E5%88%99%E9%A1%B9%E4%B8%8D%E5%BD%B1%E5%93%8DLogistic%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%87%B8%E6%80%A7/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.9/%E6%AD%A3%E5%88%99%E9%A1%B9%E4%B8%8D%E5%BD%B1%E5%93%8DLogistic%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%87%B8%E6%80%A7/</guid><description>正则项不影响Logistic回归损失函数凸性 2021-09-11 Tags: #MachineLearning #LogisticRegression #Regularization #ConvexOptimization #CostFunction
首先, 没有加正则项的二阶导数如下 那么只需要计算正则项的二阶导数 $$\begin{align} J(\theta)&amp;amp;=P(\theta)+\frac\lambda{2m}\sum^n_{i=1}\theta_i^2 \end{align}$$
$$\begin{aligned} \frac{\partial^2}{\partial \theta_{j}^2} \left(\frac\lambda{2m}\sum^n_{i=1}\theta_i^2\right)&amp;amp;= \frac{\lambda}{m}\frac{\partial}{\partial \theta_{j}} \theta_{j}\ &amp;amp;=\frac{\lambda}{m}&amp;gt;0 \end{aligned}$$ 所以损失函数还是凸的</description></item><item><title>Part.18_Regularization_Intuition(ML_Andrew.Ng.)</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.9/Part.18_Regularization_IntuitionML_Andrew.Ng./</link><pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.9/Part.18_Regularization_IntuitionML_Andrew.Ng./</guid><description>Regularization: Intuition 2021-09-10 Tags: #MachineLearning #Regularization
如果我们约束的参数&amp;quot;加大权重&amp;quot;, 那么在优化的时候就会重点最小化那些加了权重的参数. E.g. $$ \theta_{0}+\theta_{1} x+\theta_{2} x^{2}+\theta_{3} x^{3}+\theta_{4} x^{4} $$ We&amp;rsquo;ll want to eliminate the influence of $\theta_{3} x^{3}$ and $\theta_{4} x^{4}$.</description></item><item><title>Part.19_Regularized_Linear_Regression(ML_Andrew.Ng.)</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.9/Part.19_Regularized_Linear_RegressionML_Andrew.Ng./</link><pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.9/Part.19_Regularized_Linear_RegressionML_Andrew.Ng./</guid><description>Regularization &amp;amp; Linear Regression 2021-09-10 Tags: #MachineLearning #Regularization #GradientDescent #LinearRegression #NormalEquation
Regularization &amp;amp; Gradient Descent 添加了正则项之后有两点需要注意:
$\theta_0$需要单独处理 (不需要正则约束, 损失函数不一样) $\theta_1 \sim \theta_n$ 因为需要正则化, 损失函数$J(\theta)$发生了变化, 梯度需要重新计算 正则项不影响线性回归损失函数的凸性 同时考虑上面两点, 梯度下降更新公式变为了:</description></item><item><title>正则项不影响线性回归损失函数的凸性</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.9/%E6%AD%A3%E5%88%99%E9%A1%B9%E4%B8%8D%E5%BD%B1%E5%93%8D%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%B8%E6%80%A7/</link><pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.9/%E6%AD%A3%E5%88%99%E9%A1%B9%E4%B8%8D%E5%BD%B1%E5%93%8D%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%B8%E6%80%A7/</guid><description>正则项不影响线性回归损失函数的凸性 2021-09-10 Tags: #MachineLearning #Regularization #GradientDescent #LinearRegression #ConvexOptimization
Question: 加上正则项以后函数还是凸的吗? 梯度下降还适用吗? 还是适用的, 证明如下 首先, 如何证明一个函数为凸函数? 如果$f$是二阶可微的，那么如果$f$的定义域是凸集，并且$\forall x\in dom(f), \nabla^2 f(x)\geqslant0$，那么$f$ 就是一个凸函数.</description></item><item><title>正则项会消除正规方程法可能的不可逆性</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.9/%E6%AD%A3%E5%88%99%E9%A1%B9%E4%BC%9A%E6%B6%88%E9%99%A4%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B%E6%B3%95%E5%8F%AF%E8%83%BD%E7%9A%84%E4%B8%8D%E5%8F%AF%E9%80%86%E6%80%A7/</link><pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.9/%E6%AD%A3%E5%88%99%E9%A1%B9%E4%BC%9A%E6%B6%88%E9%99%A4%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B%E6%B3%95%E5%8F%AF%E8%83%BD%E7%9A%84%E4%B8%8D%E5%8F%AF%E9%80%86%E6%80%A7/</guid><description>Normal Equation Non-invertibility &amp;amp; Regularization 2021-09-10 Tags: #NormalEquation #Regularization
$(X^{T} X+\lambda \cdot L)$的内部如下图所示: 最关键的位置就是最左上角的那个地方, 如果那个位置不为0 (或者第一行/列上某个位置不为零, 也可以移过去), 那么容易知道这个矩阵一定可逆(满秩), 因为L就是单位矩阵除去第一个1. 如果上面第一行第一列元素全部为零, 那么一定是因为第一个特征($\theta_0$对应的特征)构成的向量为零向量(X里面黄色的部分), 但是如果是这样, 将这一列与其他特征交换, 便可在乘积矩阵的第一行/列得到非零的元素(因为不可能有两个特征都是零向量, 如果有, 那么便是多余的向量, 删除便可(emm这样一想好像零向量本来就是多余的)) 从而得知最后的矩阵加和一定是满秩的, 证毕.</description></item><item><title>Norm_of_a_Vector-Matrix</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.8/Norm_of_a_Vector-Matrix/</link><pubDate>Fri, 20 Aug 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.8/Norm_of_a_Vector-Matrix/</guid><description>向量/矩阵的范数 2021-08-20 Tags: #Norm #Math #MachineLearning #Regularization
https://zh.wikipedia.org/wiki/%E8%8C%83%E6%95%B0</description></item></channel></rss>
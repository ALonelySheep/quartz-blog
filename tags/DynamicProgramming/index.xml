<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DynamicProgramming on</title><link>https://alonelysheep.github.io/quartz-blog/tags/DynamicProgramming/</link><description>Recent content in DynamicProgramming on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://alonelysheep.github.io/quartz-blog/tags/DynamicProgramming/index.xml" rel="self" type="application/rss+xml"/><item><title>D2L-63-Beam Search</title><link>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.4/D2L-63-Beam-Search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.4/D2L-63-Beam-Search/</guid><description>束搜索 2022-04-20 Tags: #BeamSearch #DynamicProgramming
在 Seq2Seq里面预测的时候, 我们直接就将上一步预测概率最大的选项输入到下一个时间步, 其实这是一种贪心策略: 最大化当前时间步的预测概率. 而贪心算法常常不能找到全局的最优解, 我们能怎样改进呢? 贪心 Greedy Search 我们先来评估一下贪心算法的时间复杂度, 我们需要计算 $T$ 个时间步的 $|\mathcal{Y}|$ 个概率, 总的时间复杂度为: $$\mathcal{O}({T}\cdot\left|\mathcal{Y}\right|)$$</description></item></channel></rss>
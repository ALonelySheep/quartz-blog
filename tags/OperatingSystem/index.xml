<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OperatingSystem on</title><link>https://alonelysheep.github.io/quartz-blog/tags/OperatingSystem/</link><description>Recent content in OperatingSystem on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 18 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://alonelysheep.github.io/quartz-blog/tags/OperatingSystem/index.xml" rel="self" type="application/rss+xml"/><item><title>cmd_powershell_bash-Comparison</title><link>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.3/cmd_powershell_bash-Comparison/</link><pubDate>Fri, 18 Mar 2022 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.3/cmd_powershell_bash-Comparison/</guid><description>CMD / Powershell / bash: Comparison 2022-03-18 Tags: #Terminal #OperatingSystem
Bash是Unix系统的, 而前两个是Windows的 Powershell是CMD的升级版</description></item><item><title>OS-12-内存管理</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.12/OS-12-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.12/OS-12-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>内存管理 2021-12-11 Tags: #OperatingSystem/Memory
程序运行不仅需要处理机, 还需要有地方来保存代码与数据, 这一节我们谈论计算机在运行时, 这些这些数据是如何管理的.
目标 电脑的内存总是有限的, 我们想要用有限的内存满足更多的程序的需要, 并且还想这些程序运行得越快越好. 在容量上, 为了营造一个内存&amp;quot;无限大&amp;quot;的假象, 我们可以从&amp;quot;开源&amp;quot;, &amp;ldquo;节流&amp;quot;两方面来入手: 节流就是要减少不必要的内存浪费. 分段把程序分成大小不同的段, 避免了程序内部大段的空白.</description></item><item><title>OS-11_中断</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.11/OS-11_%E4%B8%AD%E6%96%AD/</link><pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.11/OS-11_%E4%B8%AD%E6%96%AD/</guid><description>中断 2021-11-28 Tags: #OperatingSystem
我觉得我对UNIX进程管理一直迷迷糊糊的原因就是还是对中断与上下文切换迷迷糊糊, 学习的顺序没有理清.
我们来重新梳理一下:
硬件 UNIX v6++ 建立在x86平台上面, 下面的叙述都是基于 x86 的 中断控制器 中断需要硬件支持, 即中断控制器, 用于处理外设中断</description></item><item><title>Call_Stack(Stack_Frame)的构成</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.10/Call_StackStack_Frame%E7%9A%84%E6%9E%84%E6%88%90/</link><pubDate>Thu, 07 Oct 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.10/Call_StackStack_Frame%E7%9A%84%E6%9E%84%E6%88%90/</guid><description>Call Stack 2021-10-07 Tags: #Stack #OperatingSystem #Assembly
两个非常好的视频:</description></item></channel></rss>
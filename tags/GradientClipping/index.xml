<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GradientClipping on</title><link>https://alonelysheep.github.io/quartz-blog/tags/GradientClipping/</link><description>Recent content in GradientClipping on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 02 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://alonelysheep.github.io/quartz-blog/tags/GradientClipping/index.xml" rel="self" type="application/rss+xml"/><item><title>D2L-54-Gradient Clipping-梯度剪裁</title><link>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.4/D2L-54-Gradient-Clipping-%E6%A2%AF%E5%BA%A6%E5%89%AA%E8%A3%81/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.4/D2L-54-Gradient-Clipping-%E6%A2%AF%E5%BA%A6%E5%89%AA%E8%A3%81/</guid><description>Gradient Clipping 2022-04-02 Tags: #GradientClipping
梯度剪裁是预防梯度爆炸的一种方法, 它直接给梯度设置一个上限. $$\mathbf{g} \leftarrow \min \left(1, \frac{\theta}{|\mathbf{g}|}\right) \mathbf{g}$$
上面的写法有点绕, 因为为了保持梯度 $\mathbf{g}$ 的方向不变, 剪裁时需要作用于 $\mathbf{g}$ 的每一个分量, 整体上来说其实就是: $$\mathbf{g} \leftarrow \min \left(|\mathbf{g}|, \theta \frac{\mathbf{g}}{|\mathbf{g}|}\right)$$ 相比直接减小学习率，Clipping是分段的, 可以只在梯度较大时加以限制.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Course on</title><link>https://alonelysheep.github.io/quartz-blog/tags/Course/</link><description>Recent content in Course on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 05 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://alonelysheep.github.io/quartz-blog/tags/Course/index.xml" rel="self" type="application/rss+xml"/><item><title>Compiler-4_LR分析</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.10/Compiler-4_LR%E5%88%86%E6%9E%90/</link><pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.10/Compiler-4_LR%E5%88%86%E6%9E%90/</guid><description>LR 分析 2021-11-05 Tags: #Compiler #Course
在自底向上语法分析中, 如何寻找句柄是关键问题 Compiler-4-1_什么是 LR 分析
Compiler-4-2_LR(0)_Parse
Compiler-4-3_SLR_parse
Compiler-4-4_LR(1)_分析</description></item><item><title>Compiler-2_Bottom-Up_Parsing-自底向上分析</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.10/Compiler-2_Bottom-Up_Parsing-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%88%86%E6%9E%90/</link><pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.10/Compiler-2_Bottom-Up_Parsing-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%88%86%E6%9E%90/</guid><description>Bottom-Up Parsing 2021-10-30 Tags: #Compiler #Course
自底向上分析是一种语法分析方法, 它从语法树的下边缘(即一堆终结符)开始, 逐步向上构建这个句子的推导过程
一般来说, 自底向上分析比自上而下分析要更强大, 同时也更复杂.
Shift-reduce parsing1 移位-规约分析(Shift-Reduce Parsing)是自底向上分析的主流方法 有许多不同的移位规约分析方法: 比如: &amp;ldquo;算符优先分析&amp;rdquo;和&amp;quot;LR分析&amp;quot;都属于移位规约分析.</description></item><item><title>Compiler-3_算符优先分析</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.10/Compiler-3_%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90/</link><pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.10/Compiler-3_%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90/</guid><description>Operator-precedence grammar 2021-10-30 Tags: #Compiler #Course #FormalLanguage
算符优先文法 算符优先文法(OPG)是一种有特殊性质的上下文无关文法(CFG)
它的特殊性质表现为:
产生式右部不能为空 (即没有 $P\rightarrow \varepsilon$) 产生式右边不能有两个连续的非终结符 (即没有 $P\rightarrow \cdots AB\cdots$) 上述规则使得我们可以定义终结符之间的&amp;quot;优先级&amp;quot;(Precedence), ( 为什么?</description></item><item><title>Part.29_Fisher_Linear_Discriminant(Pattern_Classification-Chapter_4)</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.10/Part.29_Fisher_Linear_DiscriminantPattern_Classification-Chapter_4/</link><pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.10/Part.29_Fisher_Linear_DiscriminantPattern_Classification-Chapter_4/</guid><description>Fisher Linear Discriminant 2021-10-28 Tags: #MachineLearning #PatternClassification #Course #DimensionalityReduction
通过降维进行分类, 降到一维即为线性判别. 其实, 线性判别分析 (LDA)就是对Fisher线性判别的归纳.1 Motivation Curse of Dimensionality - 模型的表现随着维度的增加而变坏, 而且根据设计者的3维直觉, 无法很好的解决高维度的问题.</description></item><item><title>Hash函数_Pt.1_数据完整性</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/Hash%E5%87%BD%E6%95%B0_Pt.1_%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/Hash%E5%87%BD%E6%95%B0_Pt.1_%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7/</guid><description>4.1 Hash 函数与数据完整性 Hash 函数的主要目的就是为了保持数据的完整性 与&amp;quot;加密&amp;quot;不同, hash函数的目的不是为了让一个消息对其他人&amp;quot;不可知,不可理解&amp;quot;, 而是为了保证这条信息没有被篡改, 为了&amp;quot;不变质&amp;quot;地保存一条信息, 即保持这条信息原来的模样
Hash函数有两种, 一种是带密钥的, 一种是不带密钥的, 两种在应用场景上有一些区别
不带密钥的Hash函数可以在一段时间内验证数据的完整性。 想象一个Oracle(先知, 谕示器), 你提供给他一条信息, 她总会返回给你一个独特的信息，通过比对这个信息，你就能够知道自己的信息从上次询问到现在之间是否被篡改了（但是这个信息本身并没有什么实际含义）
注意, 你必须要安全的保存 $y=h(x)$, 否则坏蛋可以同时更换你的 $x$ -&amp;gt; $x^\prime$ 和 $y$ -&amp;gt; $y^\prime=h(x^\prime)$, 你在询问的时候依然有 $h(x^\prime)=y^\prime$, 满足校验条件.</description></item><item><title>Hash函数_Pt.2_攻击方法_安全性</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/Hash%E5%87%BD%E6%95%B0_Pt.2_%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95_%E5%AE%89%E5%85%A8%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/Hash%E5%87%BD%E6%95%B0_Pt.2_%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95_%E5%AE%89%E5%85%A8%E6%80%A7/</guid><description>Hash函数的攻击方法/安全性 密码学原理与实践 page99
理想的安全性:随机谕示模型(Random Oracle Model) 完全的随机对应性:
从名称来理解, 即理想的Hash函数相当于一个&amp;quot;先知&amp;quot;, 能够对每一个$x$给出一个完全随机的$hash(x)$, 并且计算$hash(x)$的唯一方法便是询问Oracle(谕示器)
在这个假设下,有如下定理:
密码学原理与实践 page94
直观理解:</description></item><item><title>Hash函数_Pt.3_迭代Hash函数</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/Hash%E5%87%BD%E6%95%B0_Pt.3_%E8%BF%AD%E4%BB%A3Hash%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/Hash%E5%87%BD%E6%95%B0_Pt.3_%E8%BF%AD%E4%BB%A3Hash%E5%87%BD%E6%95%B0/</guid><description>迭代Hash函数 迭代Hash函数的基本结构 迭代Hash函数是一种用有限长度Hash函数来处理无限长度的数据的方法
下面这张图形象地表示了迭代Hash函数地加密步骤: 这样的构造方法可以概括为以下的三个步骤:
我们以有限的Hash函数$compress$为基础 $$ {0,1}^{m+t}\longrightarrow {0,1}^{m} $$ 这是一个将长度从$m+t$缩减到$m$的有限长度hash函数
预处理 这一步将明文切分成长度为t的小段. &amp;ndash;&amp;gt;最后剩余的怎么办?
在末尾添加整个字符串的长度
如果还不够,用0补足 &amp;ndash;&amp;gt;为什么要添加字符串的长度?</description></item><item><title>Hash函数_Pt.4_安全Hash算法_SHA-1</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/Hash%E5%87%BD%E6%95%B0_Pt.4_%E5%AE%89%E5%85%A8Hash%E7%AE%97%E6%B3%95_SHA-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/Hash%E5%87%BD%E6%95%B0_Pt.4_%E5%AE%89%E5%85%A8Hash%E7%AE%97%E6%B3%95_SHA-1/</guid><description>SHA-1 Tags: #Cryptography #Math #Course #Hash
SHA-1是一个具有160bit消息摘要的迭代Hash函数
主要思想 SHA-1 的分组大小是 512bit, 意味着每一次迭代处理 512bit 的数据
SHA-1建立在对比特串面向字的操作上, 意味着在处理512bit的时候是每次32bit, 一共16次, 一共80次. (为什么变多了? 因为在循环里面需要将16个字扩充到80个字, 如下图)</description></item><item><title>Hash函数_Pt.5_消息认证码_MAC</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/Hash%E5%87%BD%E6%95%B0_Pt.5_%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81_MAC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/Hash%E5%87%BD%E6%95%B0_Pt.5_%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81_MAC/</guid><description>消息认证码 MAC Message Authentication Code 消息认证码是什么 生成方式: 带密钥的Hash函数, Hash值可以不用在安全的信道上传输, 只需要开始的时候协商一个密钥$K$就可以了
用于核验在不安全信道上传输的消息有没有被修改
不安全的构造方式 一个很直观的方式便是把密钥$K$加到明文x里面,一起Hash, 既然攻击者不知道$K$是什么, 他也应该无法计算$h_K(x)=h(x_K). (x_K$为加入了K的x)
但是以下论证告诉我们一些简单的构造方式并不安全, 攻击者即使不知道K是什么, 也可以利用一个有效对$(x,h_K(x))$计算新的有效对$(x^\prime,h_K(x^\prime)$
直接把K作为$IV$ (IV 即 Compress 的初始输入 见迭代Hash函数的基本结构)</description></item><item><title>代换密码（Substitution Cipher）与置换密码（Permutation Cipher）</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/%E4%BB%A3%E6%8D%A2%E5%AF%86%E7%A0%81Substitution-Cipher%E4%B8%8E%E7%BD%AE%E6%8D%A2%E5%AF%86%E7%A0%81Permutation-Cipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/%E4%BB%A3%E6%8D%A2%E5%AF%86%E7%A0%81Substitution-Cipher%E4%B8%8E%E7%BD%AE%E6%8D%A2%E5%AF%86%E7%A0%81Permutation-Cipher/</guid><description>代换密码与置换密码（Substitution Cipher &amp;amp; Permutation Cipher） Tags: #Math #Cryptography #Course
分不清楚这两个完全是翻译的锅
置换（不是置换密码）Permutation（Not Permutation Cipher) 首先置换是数学上的一种操作，是对一组确定的元素进行重新排列
元素不变 只改变顺序 Wikipedia:</description></item><item><title>图灵归约 Turing Reduction</title><link>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/%E5%9B%BE%E7%81%B5%E5%BD%92%E7%BA%A6-Turing-Reduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2021/2021.6/%E5%9B%BE%E7%81%B5%E5%BD%92%E7%BA%A6-Turing-Reduction/</guid><description>把还没解决的问题归约到已经解决的问题上
用已经解决的问题去解决还没解决的问题
密码学原理与实践 Page 167
假设我们已经存在一个解决问题 A 的算法 $G(x)$
一个A到B的图灵归约即利用$G(x)$构造一个解决问题B的算法$H(x)$, 并且$H(x)$是多项式时间的.
https://zhuanlan.zhihu.com/p/194313998 这篇文章译自 reductions-and-jokes</description></item><item><title>滑动窗口协议信道利用率分析</title><link>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.4/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alonelysheep.github.io/quartz-blog/notes/2022/2022.4/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87%E5%88%86%E6%9E%90/</guid><description>滑动窗口协议信道利用率分析 Link Utilization of Sliding Window Protocols 1953184 傅驰原 2022-04-25 Tags: #ComputerNetwork #Course
我们假设某一帧出错的概率相等且独立, 并且都为 $P$ 1Bit滑动窗口 这其实是一种窗口大小为 $1$, 帧序号位数也为 $1$ 的特殊回退 $N$ 协议.</description></item></channel></rss>
<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Operator-precedence grammar 2021-10-30 Tags: #Compiler #Course #FormalLanguage
算符优先文法   算符优先文法(OPG)是一种有特殊性质的上下文无关文法(CFG)
  它的特殊性质表现为:
 产生式右部不能为空 (即没有 $P\rightarrow \varepsilon$) 产生式右边不能有两个连续的非终结符 (即没有 $P\rightarrow \cdots AB\cdots$)    上述规则使得我们可以定义终结符之间的&#34;优先级&#34;(Precedence), ( 为什么?"><title>Compiler-3_算符优先分析</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon type=image/png sizes=16x16 href=favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=favicon-32x32.png><link rel=manifest href=site.webmanifest><link href=https://alonelysheep.github.io/quartz-blog/styles.7153093e4d1bbb584a28469cadfa3f88.min.css rel=stylesheet><link href=https://alonelysheep.github.io/quartz-blog/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://alonelysheep.github.io/quartz-blog/js/darkmode.753e6a835409aa87fdd04fabb270d592.min.js></script>
<script src=https://alonelysheep.github.io/quartz-blog/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://alonelysheep.github.io/quartz-blog/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://alonelysheep.github.io/quartz-blog/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://alonelysheep.github.io/quartz-blog/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://alonelysheep.github.io/quartz-blog/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://alonelysheep.github.io/quartz-blog/",fetchData=Promise.all([fetch("https://alonelysheep.github.io/quartz-blog/indices/linkIndex.04fdb58f9cd6a736acd4876488f75bec.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://alonelysheep.github.io/quartz-blog/indices/contentIndex.c239ce7c3494c7e366c02c0c0afec4e1.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://alonelysheep.github.io/quartz-blog",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://alonelysheep.github.io/quartz-blog",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:.3,scale:.5}:{centerForce:1,depth:2,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:1.5,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/alonelysheep.github.io\/quartz-blog\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://alonelysheep.github.io/quartz-blog/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://alonelysheep.github.io/quartz-blog/>Cyan's Blog</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Compiler-3_算符优先分析</h1><p class=meta>Last updated
Oct 30, 2021
<a href=https://github.com/alonelysheep/quartz-blog/tree/hugo/content/notes/2021/2021.10/Compiler-3_%e7%ae%97%e7%ac%a6%e4%bc%98%e5%85%88%e5%88%86%e6%9e%90.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://alonelysheep.github.io/quartz-blog/tags/all/>All</a></li><li><a href=https://alonelysheep.github.io/quartz-blog/tags/Compiler/>Compiler</a></li><li><a href=https://alonelysheep.github.io/quartz-blog/tags/Course/>Course</a></li><li><a href=https://alonelysheep.github.io/quartz-blog/tags/FormalLanguage/>Formal language</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#算符优先文法>算符优先文法</a></li><li><a href=#main-differences-with-respect-to-lr-parsers>Main differences with respect to LR parsers</a><ol><li><a href=#算符优先文法的核心特征>算符优先文法的核心特征</a></li><li><a href=#history>History</a></li></ol></li><li><a href=#算符优先级>算符优先级</a><ol><li><a href=#怎么确定优先级>怎么确定优先级</a></li></ol></li><li><a href=#分析步骤>分析步骤</a><ol><li><a href=#检查是否有ε-产生式>检查是否有ε-产生式</a></li><li><a href=#firstvtnt-lastvtnt>FIRSTVT(NT), LASTVT(NT)</a></li><li><a href=#构造优先级表>构造优先级表</a></li><li><a href=#最左素短语算符优先分析中的可归约串>最左素短语—算符优先分析中的可归约串</a></li><li><a href=#start-parsing>Start Parsing!</a></li><li><a href=#优先函数>优先函数</a></li></ol></li></ol></nav></details></aside><a href=#operator-precedence-grammar><h1 id=operator-precedence-grammar><span class=hanchor arialabel=Anchor># </span>Operator-precedence grammar</h1></a><div align=right>2021-10-30</div><p>Tags: #Compiler #Course #FormalLanguage</p><a href=#算符优先文法><h2 id=算符优先文法><span class=hanchor arialabel=Anchor># </span>算符优先文法</h2></a><ul><li><p>算符优先文法(OPG)是一种<strong>有特殊性质的上下文无关文法</strong>(CFG)</p></li><li><p>它的特殊性质表现为:</p><ul><li>产生式右部不能为空 (即没有 $P\rightarrow \varepsilon$)</li><li>产生式右边不能有两个连续的非终结符 (即没有 $P\rightarrow \cdots AB\cdots$)</li></ul></li><li><p>上述规则使得我们可以定义终结符之间的"优先级"(Precedence), (
<a rel=noopener class="internal-link broken" data-src=#%e7%ae%97%e7%ac%a6%e4%bc%98%e5%85%88%e6%96%87%e6%b3%95%e7%9a%84%e6%a0%b8%e5%bf%83%e7%89%b9%e5%be%81>为什么?</a>)</p></li><li><p>算符优先分析不是规范规约, 它的每一步不一定替换句柄</p></li><li><p>在书里面的定义中, <strong>算符文法</strong>是不含两个连续非终结符的文法, <strong>算符优先文法</strong>则是终结符之间最多只有一种优先关系的<strong>算符文法</strong></p></li></ul><blockquote><a href=#main-differences-with-respect-to-lr-parsers><h2 id=main-differences-with-respect-to-lr-parsers><span class=hanchor arialabel=Anchor># </span>Main differences with respect to LR parsers</h2></a><ul><li>There is <strong>no explicit state</strong> associated to the parser (and thus no state pushed on the stack)</li><li>The decision of whether to shift or reduce is taken <strong>based solely on the symbol on the top of the stack and the next input symbol</strong> (and stored in a shift-reduce table)</li><li>In case of reduction, the handle is the longest sequence at the top of stack matching the RHS of a rule</li></ul></blockquote><a href=#算符优先文法的核心特征><h3 id=算符优先文法的核心特征><span class=hanchor arialabel=Anchor># </span>算符优先文法的核心特征</h3></a><p>有几个概念我感到很难理解:</p><ul><li>为什么算符优先文法要叫"算符优先"文法? 如果是因为它定义了运算符之间的优先级, 那么:</li><li>运算符的优先级怎样帮助我们进行语法分析?</li><li>为什么"产生式没有两个连续的终结符"便可以定义运算符之间的优先级? 如果有了两个连续的终结符又会怎样干扰算符优先分析的正确进行?</li></ul><blockquote><ul><li>算符优先分析法是<strong>仿效四则运算的计算过程而构造的一种语法分析方法</strong>。算符优先分析法的关键是比较两个相继出现的终结符的优先级而决定应采取的动作。<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li>&ldquo;仿效四则运算的计算过程&rdquo; - 何以见得?</li></ul></blockquote><ul><li><p>总之, 算符优先分析的核心概念还是像一团难以捉摸的雾</p></li><li><p>仿照四则运算可否这样理解:
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-28.png width=auto alt></p></li><li><p>Oberlin University的PPT<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>为我们提供了一种新的思路:</p></li></ul><p>我们首先定义"括号文法(parenthesis grammar)":</p><ul><li>a) The right hand side of every rule is enclosed in parentheses.</li><li>b) Parentheses occur nowhere else.</li><li>c) No two rules have the same right hand side.
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-29.png width=auto alt></li><li><strong>The parentheses make the prime phrases disjoint</strong>. The handle is always the leftmost prime phrase.</li></ul><p>那么我们可以这样理解优先级文法:</p><ul><li>Def. A simple <strong>precedence grammar</strong> is one <strong>in which we can insert symbols &ldquo;&lt;&rdquo;, &ldquo;=&rdquo;, and &ldquo;>&rdquo; to produce a language</strong> (treating &ldquo;&lt;&rdquo; and &ldquo;>&rdquo; as parentheses) that can be parsed like a parenthesized grammar.</li></ul><p>一个"优先级文法"产生的句子是一串嵌套的括号.
一个素短语便是一对括号, 我们不断消除最左边的素短语, 暴露下面的(栈里面的)素短语
嵌套的"越深"的括号"堆的越高", 我们parse的过程便是不断让这个山变矮的过程.
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-30.png width=auto alt></p><ul><li><p>理解"句子括号":
We always start with &ldquo;&lt;&rdquo; and the first token on the stack, and at EOF push &ldquo;>&rdquo;. We should end with the Start symbol on the stack.</p></li><li><p>理解算符文法:
关于为什么没有两个连续非终结符, 便可以称之为"算符文法",我实在找不到更详细的资料了, 下面那篇论文里面的这段话似乎是其最初的定义:
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-31.png width=auto alt>
注意这个性质; 如果产生式里面没有两个连续的非终结符, 那么任意句型里面也不可能有两个连续的非终结符:</p></li><li><p>证明:
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-32.png width=auto alt>
我猜测因为因为算术表达式里面都是算子和算符交替出现, 所以会有"算符文法"这个名字.</p></li></ul><p>综上, 结合"算符"文法和"优先级"文法, 便有了"算符优先文法"</p><a href=#history><h3 id=history><span class=hanchor arialabel=Anchor># </span>History</h3></a><p>Robert W. Floyd. 1963. Syntactic Analysis and Operator Precedence. <em>J. ACM</em> 10, 3 (July 1963), 316–333. DOI:https://doi.org/10.1145/321172.321179</p><p>没有细致的考证过出处, 只是谷歌搜索到的, 但是根据文章内容猜测应当是出处.</p><p>在文章里面, 我理解到了以下概念:</p><ul><li>理解"<strong>素短语</strong>":<ul><li>A prime phrase is a phrase which contains at least one terminal character, but no prime phrase other than itself.</li><li>素短语里面的"素", 指代的是Prime, 也就是素数的"素", 应当理解为"最基本的, 最原初的", 因为素数是"最小不可分的数"(算术基本定理<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>)</li></ul></li><li>理解课本里面的"句子括号: #"<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup><ul><li>对于 $BxC$, 其中B, C为终结符
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-33.png width=auto alt></li><li>像上面这样记忆其实比"把#当作一个终结符"简单</li></ul></li></ul><a href=#算符优先级><h2 id=算符优先级><span class=hanchor arialabel=Anchor># </span>算符优先级</h2></a><p><strong>a ⋖ b</strong> This means a “yields precedence to” b.<br><strong>a ⋗ b</strong> This means a “takes precedence over” b.<br><strong>a ≐ b</strong> This means a “has same precedence as” b.</p><a href=#怎么确定优先级><h3 id=怎么确定优先级><span class=hanchor arialabel=Anchor># </span>怎么确定优先级</h3></a><ul><li><p><strong>a等于b</strong>
当且仅当 文法G中含有形如$P→ \cdots ab\cdots$ 或 $P→\cdots aQb\cdots$的产生式；</p></li><li><p><strong>a小于b</strong>
当且仅当 G中含有形如$P→\cdots aR\cdots$ 的产生式，而$R \overset{+}{\Rightarrow}b\cdots$ 或$R\overset{+}{\Rightarrow}Qb\cdots$
即语法树中, a在b的左上面</p></li><li><p><strong>a大于b</strong>
当且仅当 G中含有形如$P→\cdots Rb\cdots$ 的产生式，而$R\overset{+}{\Rightarrow}\cdots a$或$R\overset{+}{\Rightarrow}\cdots aQ$
即语法树中, a在b的左下面</p><p>在算符优先文法里面, 任意两个终结符 <strong>至多满足一种关系</strong></p></li></ul><a href=#分析步骤><h2 id=分析步骤><span class=hanchor arialabel=Anchor># </span>分析步骤</h2></a><p><img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-34.png width=auto alt>
前三步都是在进行准备工作, 即构造后面要用到的算符优先表,
同时, 确定优先级的过程也是验证这个文法是不是算符优先文法的过程</p><a href=#检查是否有ε-产生式><h3 id=检查是否有ε-产生式><span class=hanchor arialabel=Anchor># </span>检查是否有ε-产生式</h3></a><a href=#firstvtnt-lastvtnt><h3 id=firstvtnt-lastvtnt><span class=hanchor arialabel=Anchor># </span>FIRSTVT(NT), LASTVT(NT)</h3></a><ul><li>构造对象: 所有非终结符</li><li>定义:
$$\begin{aligned}
&\operatorname{FIRSTVT}(\mathrm{P})=\left{\mathrm{a} \mid \mathrm{P} \stackrel{+}{\Rightarrow} \mathrm{a} \cdots \text { 或 }{\mathrm{P}} \stackrel{+}{\Rightarrow} \mathrm{Qa}\cdots , \mathrm{a} \in \mathrm{V}<em>{\mathrm{T}} \text { 而 } \mathrm{Q} \in \mathrm{V}</em>{\mathrm{N}}\right} \\ &\mathrm{LASTVT}(\mathrm{P})=\left{\mathrm{a} \mid \mathrm{P} \stackrel{+}{\Rightarrow} \cdots \mathrm{a} \text { 或 } \mathrm{P} \stackrel{+}{\Rightarrow} \cdots \mathrm{aQ}, \mathrm{a} \in \mathrm{V}<em>{\mathrm{T}} \text { 而 } \mathrm{Q} \in \mathrm{V}</em>{\mathrm{N}}\right}
\end{aligned}$$</li><li>FIRSTVT: 非终结符的所有第一个(FIRST)终结符(VT)</li><li>LASTVT: 非终结符的所有最后一个(LAST)终结符(VT)</li></ul><a href=#如何构造-firstvtnt-lastvtnt><h4 id=如何构造-firstvtnt-lastvtnt><span class=hanchor arialabel=Anchor># </span>如何构造 FIRSTVT(NT), LASTVT(NT)</h4></a><ul><li>递归构造</li></ul><a href=#firstvtb><h5 id=firstvtb><span class=hanchor arialabel=Anchor># </span>FIRSTVT(B)</h5></a><ul><li>首先所有产生式$B→a\cdots$, 或者 $B→Ca\cdots$, 有 $a\in FIRSTVT(B)$</li><li>然后对于所有的$B→Ca\cdots$, 有$FIRSTVT(B) = FIRSTVT(C)\cup FIRSTVT(B)$</li></ul><p>这样的话可能会套很多层, 书上采用的方法是用一个栈:
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-35.png width=auto alt></p><ul><li>首先, 将直接能够看出来的元素在表中标记, 并且入栈.
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-36.png width=auto alt></li><li>然后, 将栈顶元素$(C, d)$出栈, 如果C是某一个产生式的第一个非终结符(比如$B→Ca\cdots$), 那么将$d$加入到$FIRSTVT(B)$里面.</li><li>标记$(B, d)$, 同时$(B, d)$入栈</li><li>重复, 直到栈空</li></ul><p>理解FIRSTVT(B)
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-37.png width=auto alt=500>
理解这种"栈中元素对"的更新方式
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-38.png width=auto alt=500></p><a href=#lastvtb><h6 id=lastvtb><span class=hanchor arialabel=Anchor># </span>LASTVT(B)</h6></a><p>类似的</p><ul><li>首先所有产生式$B→\cdots a$, 或者 $B→\cdots aC$, 有 $a\in LASTVT(B)$</li><li>然后对于所有的$B→\cdots aC$, 有$LASTVT(B) = LASTVT(C)\cup LASTVT(B)$</li></ul><a href=#构造优先级表><h3 id=构造优先级表><span class=hanchor arialabel=Anchor># </span>构造优先级表</h3></a><blockquote><p>注意区分: 这个表是构造FIRSTVT 和 LASTVT 的, 不是优先级表
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-39.png width=auto alt=300></p></blockquote><p>然后我们根据FIRSTVT 和 LASTVT 来构造优先级表
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-40.png width=auto alt=500>
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-41.png width=auto alt=600>
构造出来长这样
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-42.png width=auto alt></p><a href=#特别注意><h4 id=特别注意><span class=hanchor arialabel=Anchor># </span>特别注意!</h4></a><p>算符优先级不满足交换律, 所以$a\lessdot b\nRightarrow b\gtrdot a$<br><strong>所以这个表格并不是反对称矩阵!!</strong>
要分清横纵轴, 在课本和课件里面, 都是
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-43.png width=auto alt=300></p><blockquote><p>课本里我们引入#符号表示句子的括号
即一开始 在文法中添加E→#E# , E为开始符号,
容易推出:</p><ul><li># ⋖ FIRSTVT(E)</li><li>LASTVT(E) ⋗ #</li><li># ≐ #
%%>
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-44.png width=auto alt=400>%%
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-45.png width=auto alt>
课件里面没有写, 但是在分析具体的句型的时候需要记住</li></ul></blockquote><a href=#最左素短语算符优先分析中的可归约串><h3 id=最左素短语算符优先分析中的可归约串><span class=hanchor arialabel=Anchor># </span>最左素短语—算符优先分析中的可归约串</h3></a><ul><li>素短语
至少含有一个终结符且除它自身之外不含有任何更小的素短语。
(语法分析树里面至少含有一个终结符的最小子树)</li><li>最左素短语
处于句型最左边的那个素短语。
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-46.png width=auto alt=600>
在算符优先句型里面, 句型一定是以下格式:
$#N_1\space a_1\space N_2\space a_2\space \cdots N_n\space a_n\space N_{n+1} #$
其中: ${a}<em>{{i}} \in {V}</em>{{T}}, {N}<em>{{i}} \in {V}</em>{{N}}$ (非终结符可有可无, 但是一定不会挨着)</li></ul><p>句型是这种形式是算符文法的定义造成的, 算符文法不允许出现两个连续的非终结符.</p><p>一个例子:
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-47.png width=auto alt=500>
直观上这样理解:
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-48.png width=auto alt=500></p><a href=#start-parsing><h3 id=start-parsing><span class=hanchor arialabel=Anchor># </span>Start Parsing!</h3></a><p><img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/img_2022-10-15-49.png width=auto alt="算符优先算法 解析">
一个具体的例子:
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/Operator_Precedence_Parse.pdf width=auto alt=Operator_Precedence_Parse></p><p>需要注意的是:</p><ul><li>算符优先分析在规约这一步上面, 得到的是"某个非终结符N", 这个非终结符是不重要的, 这在下图中可以清晰的看出:</li><li><img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/Pasted%20image%2020211030172247.png width=auto alt></li><li>上图同时说明了 算符优先分析不等价于规范归约，未必是严格的最左归约(从树里面可以看出省略了一些步骤, 即跳过了所有单非产生式所对应的归约步骤), 所以归约速度快，但容易误判(因为忽略非终结符在归约过程中的作用，存在某种危险性，可能导致把本来不是句子的输入串误认为是句子)</li><li>这也同时说明了算符优先分析没有"状态(State)&ldquo;一说, 即没有状态入栈, 推导过程完全凭借栈顶终结符与下一个终结符</li></ul><p>易错:</p><ul><li>优先级关系是每一步都有的
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/Pasted%20image%2020211030211829.png width=auto alt=400></li><li>我的:</li><li><img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/Pasted%20image%2020211030211857.png width=auto alt=400></li></ul><a href=#优先函数><h3 id=优先函数><span class=hanchor arialabel=Anchor># </span>优先函数</h3></a><p>实际应用中, 考虑到存储优先表的开销太大, 我们常常用优先函数代替优先表:
<img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/Pasted%20image%2020211030193845.png width=auto alt></p><p>函数f 称为入栈优先函数， g 称为比较优先函数</p><ul><li>若 $\theta_{1}⋖\theta_{2}\quad$ 则 $\quad f(\theta_1)&lt;g(\theta_2)$</li><li>若 $\theta_{1}≐\theta_{2}\quad$ 则 $\quad f(\theta_{1})=g(\theta_2)$</li><li>若 $\theta_{1}⋗\theta_{2}\quad$ 则 $\quad f(\theta_{1})>g(\theta_{2})$</li></ul><p>注意:</p><ul><li>不是每一个优先表都有对应的优先函数</li><li>原来优先表为空的项(不存在优先关系的终结符对), 转化为优先函数以后, 与自然数相对应，变成可以比较的。所以要进行一些特殊的判断</li><li>优先函数不唯一，只要存在一对，必存在无穷对优先函数。</li></ul><p><img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/Pasted%20image%2020211030194053.png width=auto alt=400></p><a href=#怎么画><h4 id=怎么画><span class=hanchor arialabel=Anchor># </span>怎么画</h4></a><ul><li>如果a 的优先级高于或等于b，则从 $f_a$ 至 $g_b$ 画一条有向边</li><li>如果a 的优先级低于或等于b，则从 $g_b$ 至 $f_a$ 画一条有向边</li><li>注意相等的话要画来回两条边</li><li>每个结点赋予一个数, 该数等于从该结点出发可达结点（包括出发结点本身在内）的个数.</li><li>因为可能有的表没有优先函数, 所以还要检查是否有矛盾: 是否有矛盾的优先级, 即: 是否有环?</li><li>An Illustration:</li><li><img src=https://alonelysheep.github.io/quartz-blog//notes/2021/2021.10/assets/Pasted%20image%2020211105185333.png width=auto alt><sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></li></ul><p>可以证明：
若$a≐b$, 则$f(a)=g(b)$; 若$a⋖ b$, 则$f(a)&lt;g(b)$; 若$a⋗b$, 则$f(a)>g(b)$</p><hr><p>课件上完全没有讲出错处理</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://moyangsensei.github.io/2019/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90/ rel=noopener>https://moyangsensei.github.io/2019/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90/</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p><a href=https://www.cs.oberlin.edu/~bob/cs331/Class-Notes/February/February-17/Precedence-Grammars.pdf rel=noopener>https://www.cs.oberlin.edu/~bob/cs331/Class%20Notes/February/February%2017/Precedence%20Grammars.pdf</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>不要混淆了"算术基本定理"与"代数基本定理"哦&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>我觉得, 这是一个很奇怪的称呼, 完全没有必要又造一个专有名词出来&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p><a href=https://www.geeksforgeeks.org/role-of-operator-precedence-parser/ rel=noopener>https://www.geeksforgeeks.org/role-of-operator-precedence-parser/</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/quartz-blog/notes/2021/2021.10/Compiler-2_Bottom-Up_Parsing-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%88%86%E6%9E%90/ data-ctx='"算符优先分析"' data-src=/notes/2021/2021.10/Compiler-2_Bottom-Up_Parsing-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%88%86%E6%9E%90 class=internal-link>Compiler-2_Bottom-Up_Parsing-自底向上分析</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://alonelysheep.github.io/quartz-blog/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Cyan Fu using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2022</p><ul><li><a href=https://alonelysheep.github.io/quartz-blog/>Home</a></li><li><a href=https://github.com/ALonelySheep>Github</a></li><li><a href=https://space.bilibili.com/506700150>Bilibili</a></li></ul></footer></div></div></body></html>
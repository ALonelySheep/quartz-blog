<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Why do cost functions use the square error? 2021-07-31 Tags: #MachineLearning #CostFunction #MeanSquareError
Reference: StackExchange: why-do-cost-functions-use-the-square-error?
StackExchange上面一个关于均方差的一个很好的解释, 翻译如下:
Question:  I&rsquo;m just getting started with some machine learning, and until now I have been dealing with linear regression over one variable."><title>Why_do_cost_functions_use_the_square_error</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon type=image/png sizes=16x16 href=favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=favicon-32x32.png><link rel=manifest href=site.webmanifest><link href=https://alonelysheep.github.io/quartz-blog/styles.7153093e4d1bbb584a28469cadfa3f88.min.css rel=stylesheet><link href=https://alonelysheep.github.io/quartz-blog/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://alonelysheep.github.io/quartz-blog/js/darkmode.753e6a835409aa87fdd04fabb270d592.min.js></script>
<script src=https://alonelysheep.github.io/quartz-blog/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://alonelysheep.github.io/quartz-blog/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://alonelysheep.github.io/quartz-blog/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://alonelysheep.github.io/quartz-blog/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://alonelysheep.github.io/quartz-blog/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://alonelysheep.github.io/quartz-blog/",fetchData=Promise.all([fetch("https://alonelysheep.github.io/quartz-blog/indices/linkIndex.04fdb58f9cd6a736acd4876488f75bec.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://alonelysheep.github.io/quartz-blog/indices/contentIndex.c239ce7c3494c7e366c02c0c0afec4e1.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://alonelysheep.github.io/quartz-blog",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://alonelysheep.github.io/quartz-blog",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:.3,scale:.5}:{centerForce:1,depth:2,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:1.5,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/alonelysheep.github.io\/quartz-blog\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://alonelysheep.github.io/quartz-blog/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://alonelysheep.github.io/quartz-blog/>Cyan's Blog</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Why_do_cost_functions_use_the_square_error</h1><p class=meta>Last updated
Jul 31, 2021
<a href=https://github.com/alonelysheep/quartz-blog/tree/hugo/content/notes/2021/2021.8/Why_do_cost_functions_use_the_square_error.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://alonelysheep.github.io/quartz-blog/tags/all/>All</a></li><li><a href=https://alonelysheep.github.io/quartz-blog/tags/MachineLearning/>Machine learning</a></li><li><a href=https://alonelysheep.github.io/quartz-blog/tags/CostFunction/>Cost function</a></li><li><a href=https://alonelysheep.github.io/quartz-blog/tags/MeanSquareError/>Mean square error</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#question>Question:</a></li><li><a href=#answer>Answer:</a></li><li><a href=#why-do-we-use-the-square-loss>Why do we use the square loss</a></li><li><a href=#regarding-the-frac1-2-term>Regarding the $\frac1 2$ term</a></li><li><a href=#为什么要使用平方误差>为什么要使用平方误差</a></li><li><a href=#关于损失函数里面的frac1-2>关于损失函数里面的$\frac1 2$</a></li></ol></nav></details></aside><a href=#why-do-cost-functions-use-the-square-error><h1 id=why-do-cost-functions-use-the-square-error><span class=hanchor arialabel=Anchor># </span>Why do cost functions use the square error?</h1></a><div align=right>2021-07-31</div><p>Tags: #MachineLearning #CostFunction #MeanSquareError</p><p>Reference:
<a href="https://datascience.stackexchange.com/questions/10188/why-do-cost-functions-use-the-square-error?newreg=50bfd55599464f059209bd22b6898660" rel=noopener>StackExchange: why-do-cost-functions-use-the-square-error?</a></p><p>StackExchange上面一个关于均方差的一个很好的解释, 翻译如下:</p><a href=#question><h2 id=question><span class=hanchor arialabel=Anchor># </span>Question:</h2></a><blockquote><p>I&rsquo;m just getting started with some machine learning, and until now I have been dealing with linear regression over one variable.
I have learnt that there is a hypothesis, which is:
$h_{\theta}(x)=\theta_{0}+\theta_{1} x$
To find out good values for the parameters $\theta_{0}$ and $\theta_{1}$ we want to minimize the difference between the calculated result and the actual result of our test data. So we subtract
$h_{\theta}\left(x^{(i)}\right)-y^{(i)}$
for all $i$ from 1 to $m$. Hence we calculate the sum over this difference and then calculate the average by multiplying the sum by $\frac{1}{m}$. So far, so good. This would result in:
$\frac{1}{m} \sum_{i=1}^{m} \left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)$
But this is not what has been suggested. Instead the course suggests to take the square value of the difference, and to multiply by $\frac{1}{2 m}$. So the formula is:
$\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2}$
Why is that? Why do we use the square function here, and why do we multiply by $\frac{1}{2 m}$ instead of $\frac{1}{m} ?$</p></blockquote><p>我是一个机器学习的初学者, 现在正在学习一元线性回归问题.
我学到了下面这个假设函数:
$h_{\theta}(x)=\theta_{0}+\theta_{1} x$
为了找到参数$\theta_{0}$ 和 $\theta_{1}$ 的最优值, 我们需要使预测值与真实值之间的误差最小, 所以我们把他们相减: $h_{\theta}\left(x^{(i)}\right)-y^{(i)}$ 其中 $i$ 取遍 $1$ 到 $m$.
然后我们计算所有误差的和, 并且乘上 $\frac{1}{m}$得到误差的平均数, 得到:
$\frac{1}{m} \sum_{i=1}^{m} \left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)$
但是这并不是正确的公式, 课程里面说我们需要把误差进行平方, 然后乘以$\frac{1}{2 m}$, 所以应该是
$\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2}$
为什么要这样做? 为什么我们需要将误差进行平方, 并且乘上$\frac{1}{2 m}$ 而不是 $\frac{1}{m} ?$</p><a href=#answer><h2 id=answer><span class=hanchor arialabel=Anchor># </span>Answer:</h2></a><p>Your loss function would not work because it incentivizes setting $\theta_{1}$ to any finite value and $\theta_{0}$ to $-\infty$.</p><p>Let&rsquo;s call $r(x, y)=\frac{1}{m} \sum_{i=1}^{m} \left(h_{\theta}\left(x^{(i)}\right)-y\right)$ the residual for $h$.</p><p>Your goal is to make $r$ as close to zero as possible, not just minimize it. A high negative value is just as bad as a high positive value.</p><p>EDIT: You can counter this by artificially limiting the parameter space $\boldsymbol{\Theta}$ (e.g. you want $\left|\theta_{0}\right|&lt;\mathbf{1 0}$ ). In this case, the optimal parameters would lie on certain points on the boundary of the parameter space. See
<a href=https://math.stackexchange.com/q/896388/12467 rel=noopener>https://math.stackexchange.com/q/896388/12467</a>. This is not what you want.</p><a href=#why-do-we-use-the-square-loss><h2 id=why-do-we-use-the-square-loss><span class=hanchor arialabel=Anchor># </span>Why do we use the square loss</h2></a><p>The squared error forces $h(x)$ and $y$ to match. It&rsquo;s minimized at $\boldsymbol{u}=v$, if possible, and is always $\geq 0$, because it&rsquo;s a square of the real number $\boldsymbol{u}-\boldsymbol{v}$.</p><p>$|\boldsymbol{u}-\boldsymbol{v}|$ would also work for the above purpose, as would $(\boldsymbol{u}-\boldsymbol{v})^{2 n}$, with $\boldsymbol{n}$ some positive integer. The first of these is actually used (it&rsquo;s called the $\ell_{1}$ loss; you might also come across the $\ell_{2}$ loss, which is another name for squared error).</p><p>So, why is the squared loss better than these? This is a <em>deep</em> question related to the link between Frequentist and Bayesian inference. In short, the squared error relates to <strong>Gaussian Noise</strong>.</p><p>If your data does not fit all points exactly, i.e. $h(x)-y$ is not zero for some point no matter what $\theta$ you choose (as will always happen in practice), that might be because of noise. In any complex system there will be many small <strong>independent</strong> causes for the difference between your model $h$ and reality $y$ : measurement error, environmental factors etc. By the
<a href=https://en.wikipedia.org/wiki/Central_limit_theorem rel=noopener>Central Limit Theorem</a> $(\mathrm{CLT})$, the total noise would be distributed Normally, i.e. according to the <strong>Gaussian distribution</strong>. We want to pick the best fit $\boldsymbol{\theta}$ taking this noise distribution into account. Assume $\boldsymbol{R}=\boldsymbol{h}(\boldsymbol{X})-\boldsymbol{Y}$, the part of $\mathbf{y}$ that your model cannot explain, follows the Gaussian distribution $\mathcal{N}(\mu, \sigma)$. We&rsquo;re using capitals because we&rsquo;re talking about random variables now.</p><p>The Gaussian distribution has two parameters, mean $\mu=\mathbb{E}[R]=\frac{1}{m} \sum_{i}\left(h_{\theta}\left(X^{(i)}\right)-Y^{(i))}\right)$ and variance $\sigma^{2}=E\left[R^{2}\right]=\frac{1}{m} \sum_{i}\left(h_{\theta}\left(X^{(i)}\right)-Y^{(i))}\right)^{2}$. See
<a href=https://math.stackexchange.com/questions/518281/how-to-derive-the-mean-and-variance-of-a-gaussian-random-variable rel=noopener>here</a> to understand these terms better.</p><ul><li><p>Consider $\boldsymbol{\mu}$, it is the systematic error of our measurements. Use $\boldsymbol{h}^{\prime}(\boldsymbol{x})=\boldsymbol{h}(\boldsymbol{x})-\boldsymbol{\mu}$ to correct for systematic error, so that $\boldsymbol{\mu}^{\prime}=\mathbb{E}\left[\boldsymbol{R}^{\prime}\right]=\mathbf{0}$ (exercise for the reader). Nothing else to do here.</p></li><li><p>$\sigma$ represents the random error, also called noise. Once we&rsquo;ve taken care of the systematic noise component as in the previous point, the best predictor is obtained when $\boldsymbol{\sigma}^{2}=\frac{1}{m} \sum_{i}\left(h_{\theta}\left(X^{(i)}\right)-Y^{(i))}\right)^{2}$ is minimized. Put another way, the best predictor is the one with the tightest distribution (smallest variance) around the predicted value, i.e. smallest variance. <strong>Minimizing the the least squared loss is the same thing as minimizing the variance</strong>! That explains why the least squared loss works for a wide range of problems. The underlying noise is very often Gaussian, because of the $\mathrm{CLT}$, and minimizing the squared error turns out to be the <em>right</em> thing to do!</p></li></ul><p>To simultaneously take both the mean and variance into account, we include a <em>bias</em> term in our classifier (to handle systematic error μ), then minimize the square loss.</p><p>Followup questions:</p><ul><li><strong>Least squares loss = Gaussian error. Does every other loss function also correspond to some noise distribution?</strong> Yes. For example, the $\ell_{1}$ loss (minimizing absolute value instead of squared error) corresponds to the
<a href=https://en.wikipedia.org/wiki/Laplace_distribution rel=noopener>Laplace distribution</a> (Look at the formula for the PDF in the infobox &ndash; it&rsquo;s just the Gaussian with $|\boldsymbol{x}-\boldsymbol{\mu}|$ instead of $(\boldsymbol{x}-\boldsymbol{\mu})^{2}$). A popular loss for probability distributions is the
<a href=https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence rel=noopener>KL-divergence</a>. -The Gaussian distribution is very well motivated because of the <strong>Central Limit Theorem</strong>, which we discussed earlier. When is the Laplace distribution the right noise model? There are some circumstances where it comes about naturally, but it&rsquo;s more commonly as a regularizer
<a href=https://math.stackexchange.com/q/1904767/12467 rel=noopener>to enforce <strong>sparsity</strong></a>: the $\ell_{1}$ loss is the <em>least convex</em> among all convex losses.
^b7e1c9<ul><li>As
<a href=https://datascience.stackexchange.com/users/14904/jan-van-der-vegt rel=noopener>Jan</a> mentions in the comments, the minimizer of <em>squared</em> deviations is the mean and the minimizer of the sum of <strong>absolute</strong> deviations is the <strong>median</strong>. Why would we want to find the median of the residuals instead of the mean? Unlike the mean, the median isn&rsquo;t thrown off by one very large outlier. So, the ℓ1 loss is used for increased robustness. Sometimes a combination of the two is used.</li></ul></li><li><strong>Are there situations where we minimize both the Mean and Variance?</strong> Yes. Look up
<a href=https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff rel=noopener>Bias-Variance Trade-off</a>. Here, we are looking at a set of classifiers $h_\theta \in H$ and asking which among them is best. If we ask which <em>set</em> of classifiers is the best for a problem, minimizing both the bias and variance becomes important. It turns out that there is always a trade-off between them and we use <strong>regularization</strong> to achieve a compromise. ^91cd90</li></ul><a href=#regarding-the-frac1-2-term><h2 id=regarding-the-frac1-2-term><span class=hanchor arialabel=Anchor># </span>Regarding the $\frac1 2$ term</h2></a><p>The 1/2 does not matter and actually, neither does the $m$ - they&rsquo;re both constants. The optimal value of $\theta$ would remain the same in both cases.</p><ul><li>The expression for the gradient becomes prettier with the $\frac1 2$, because the 2 from the square term cancels out.<ul><li>When writing code or algorithms, we&rsquo;re usually concerned more with the gradient, so it helps to keep it concise. You can check progress just by checking the norm of the gradient. The loss function itself is sometimes omitted from code because it is used only for validation of the final answer.</li></ul></li><li>The $m$ is useful if you solve this problem with gradient descent. Then your gradient becomes the average of $m$ terms instead of a sum, so its&rsquo; scale does not change when you add more data points.<ul><li>I&rsquo;ve run into this problem before: I test code with a small number of points and it works fine, but when you test it with the entire dataset there is loss of precision and sometimes over/under-flows, i.e. your gradient becomes <code>nan</code> or <code>inf</code>. To avoid that, just normalize w.r.t. number of data points.</li></ul></li><li>These aesthetic decisions are used here to maintain consistency with future equations where you&rsquo;ll add <strong>regularization</strong> terms. If you include the $m$, the regularization parameter λ will not depend on the dataset size $m$ and it will be more interpretable across problems.</li></ul><hr><p>你的损失函数并不正确, 因为它倾向于将$\theta_{1}$ 设置为任意有限值,并且将 $\theta_{0}$ 设置为 $-\infty$.</p><p>我们不妨把$r(x, y)=\frac{1}{m} \sum_{i=1}^{m} \left(h_{\theta}\left(x^{(i)}\right)-y\right)$ 称为 $h$的残差.</p><p>你的目标是让$r$ <strong>尽可能地接近0</strong>, <strong>不是让其尽可能地小</strong>. 一个(绝对值)很大的负数和一个很大的整数一样糟糕.</p><p><strong>附</strong>: 你也可以人为限制参数的变化范围 $\boldsymbol{\Theta}$ (比如: 令$\left|\theta_{0}\right|&lt;\mathbf{1 0}$ ). 此时,你的方法得到的最优参数会是很靠近边界的一个值. (参见
<a href=https://math.stackexchange.com/q/896388/12467 rel=noopener>https://math.stackexchange.com/q/896388/12467</a>). 这并不是我们想要的结果.</p><a href=#为什么要使用平方误差><h2 id=为什么要使用平方误差><span class=hanchor arialabel=Anchor># </span>为什么要使用平方误差</h2></a><p>平方误差会让 $h(x)$ 靠近 $y$. 它在 $\boldsymbol{u}=v$的时候取得最小值, 并且因为它是实数 $\boldsymbol{u}-\boldsymbol{v}$的平方, 它始终$\geq 0$.</p><p>$|\boldsymbol{u}-\boldsymbol{v}|$ 也有一样的效果, 正如$(\boldsymbol{u}-\boldsymbol{v})^{2 n}$, ($\boldsymbol{n}$ 是任意正数)也一样. 绝对值误差其实在实际问题中也用到了 (称为 $\ell_{1}$ 误差; 你有时也会看到 $\ell_{2}$ 误差, 这是平方误差的另一种称呼).</p><p>所以为什么平方误差比它们都好? 这个问题其实十分深入, 它涉及到了频率学派推断<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>和贝叶斯推断<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>之间的联系. 简而言之, 平方误差其实和<strong>高斯噪声</strong>有关. <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p>如果你的预测值和真实值总是对不上, 也就是无论$\theta$选什么值, 总有一些点$h(x)-y$ 不为零(这很常见). 那么很可能你的数据有噪声. 在一个复杂的系统中, 许多微小但是<strong>相互独立</strong>的因素会使 $h$ 和真实值 $y$不一样 : 比如测量误差, 环境因素等等. 根据
<a href=https://en.wikipedia.org/wiki/Central_limit_theorem rel=noopener>中心极限定理</a> Central Limit Theorem$(\mathrm{CLT})$ , 整体上这些噪声会呈正态分布, 也就是说, 它们服从 <strong>高斯分布</strong>(也称正态分布). 我们在选取 $\boldsymbol{\theta}$ 的时候, 也需要尽可能地考虑到这些因素. 假设 $\boldsymbol{R}=\boldsymbol{h}(\boldsymbol{X})-\boldsymbol{Y}$, 其中$\mathbf{y}$的有一部分是你的模型无法解释的噪声, 服从高斯分布$\mathcal{N}(\mu, \sigma)$. (我们之所以使用大写字母, 是因为它们都代表随机变量)</p><p>高斯分布包含两个变量: 期望值$\mu=\mathbb{E}[R]=\frac{1}{m} \sum_{i} h_{\theta}\left(X^{(i)}\right)-Y^{(i))}$ 和方差 $\sigma^{2}=E\left[R^{2}\right]=\frac{1}{m} \sum_{i}\left(h_{\theta}\left(X^{(i)}\right)-Y^{(i))}\right)^{2}$. 如果你想要了解更多,可以参考
<a href=https://math.stackexchange.com/questions/518281/how-to-derive-the-mean-and-variance-of-a-gaussian-random-variable rel=noopener>这个链接</a> .</p><ul><li><p>对于 $\boldsymbol{\mu}$, 它表示我们测量的系统误差. 我们可以利用$\boldsymbol{h}^{\prime}(\boldsymbol{x})=\boldsymbol{h}(\boldsymbol{x})-\boldsymbol{\mu}$ 来修正系统误差, 所以 $\boldsymbol{\mu}^{\prime}=\mathbb{E}\left[\boldsymbol{R}^{\prime}\right]=\mathbf{0}$ (你可以试一试). 这样我们便已经修正了系统误差.</p></li><li><p>$\sigma$ 代表系统的随机误差, 也称作<em>噪声</em>. 在修正了系统误差之后, 最好的预测结果在$\boldsymbol{\sigma}^{2}=\frac{1}{m} \sum_{i}\left(h_{\theta}\left(X^{(i)}\right)-Y^{(i))}\right)^{2}$ 最小的时候取得. 换句话说, 最好的预测结果在预测值周围有着最紧密的分布 (最小的方差) . <strong>取平方误差最小值的过程就是取方差最小值的过程</strong>! 这也是最小二乘法<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>适用面如此之广的原因. 一个系统里面隐藏的噪声常常是成正态分布的, 根据中心极限定理, 我们需要使平方误差最小化!</p></li></ul><p>为了同时考虑数学期望和方差, 我们在判别器里面引入了一个<em>偏置</em> (为了修正系统误差μ), 然后最小化平方误差.</p><p>进一步的问题:</p><ul><li><p><strong>最小二乘法 对应 高斯误差. 其他类型的损失函数也有对应的误差分布吗?</strong>
是的. 比如 $\ell_{1}$ 误差 (使绝对值之和最小而不是平方误差最小) 对应着
<a href=https://en.wikipedia.org/wiki/Laplace_distribution rel=noopener>拉普拉斯分布(Laplace distribution)</a> (注意观察一下拉普拉斯分布的概率密度函数 &ndash; 相当于把高斯分布 $(\boldsymbol{x}-\boldsymbol{\mu})^{2}$ 的换成 $|\boldsymbol{x}-\boldsymbol{\mu}|$).<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> 另一个常见的损失函数对应的误差分布是
<a href=/quartz-blog/notes/2022/2022.2/KL_Divergence-KL%E6%95%A3%E5%BA%A6/ rel=noopener class=internal-link data-src=/quartz-blog/notes/2022/2022.2/KL_Divergence-KL%E6%95%A3%E5%BA%A6/>KL-散度（相对熵）</a>. 我们之前提到过，因为中心极限定理，高斯分布非常常见. 那么拉普拉斯分布又在什么时候适用呢? 的确有的问题符合拉普拉斯分布, 但是拉普拉斯分布更常被用于"正则化"来
<a href=https://math.stackexchange.com/q/1904767/12467 rel=noopener>保证<strong>稀疏性(Sparsity)</strong></a>: $\ell_{1}$ 损失是所有凸损失函数里面凸起最小的. ^269677</p><ul><li>正如Jan在评论里面提到的一样, <strong>平均值</strong>使<strong>平方误差</strong>最小, 而<strong>中位数</strong>使<strong>绝对误差</strong>最小, 为什么($\ell_{1}$损失中)我们要去找残差的中位数而不是均值呢? 这是因为不像平均值, 中位数不会被很大的离群值干扰. 所以$\ell_{1}$损失被用来增加鲁棒性, 有时也会综合利用两者.</li><li>附: 答案下方的评论:<ul><li>抱歉再问一下, 为什么不用绝对值而是用平方误差? – Alexander Suraphel Sep 5 &lsquo;17 at 16:42</li><li>绝对误差也可以, 但是你就是在找中位数而不是平均值了, 你可以用一小组数据来试一试, 观察不同估计值对于两个损失函数的影响 - Jan van der Vegt Oct 26 &lsquo;17 at 10:58</li></ul></li></ul></li><li><p><strong>有没有同时最小化数学期望和方差的方法?</strong>
有. 参见
<a href=https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff rel=noopener>偏差-方差权衡_Bias-Variance Trade-off</a>. 比方说我们需要从一堆分类器$h_\theta \in H$ 里面选出最好的分类器. 如果我们需要找出<em>一组</em>最好的分类器, 那么就需要同时最小化偏差(Bias, 预期期望和真实值的差距) 和方差. 其实现实中总是需要在这两个量之间做出取舍的, 而这个取舍的过程常常通过<strong>正则化</strong>来实现.</p></li></ul><a href=#关于损失函数里面的frac1-2><h2 id=关于损失函数里面的frac1-2><span class=hanchor arialabel=Anchor># </span>关于损失函数里面的$\frac1 2$</h2></a><p>其实这个 1/2 并不重要, $m$ 也是 - 他们都是常数. $\theta$ 的最优值与它们无关.</p><ul><li>加上 $\frac1 2$会让梯度的表达式更好看,
<a href=/quartz-blog/notes/2021/2021.8/Linear_RegressionGradient_Descent/ rel=noopener class=internal-link data-src=/quartz-blog/notes/2021/2021.8/Linear_RegressionGradient_Descent/>因为平方项的2被约掉了</a>.<ul><li>在设计算法和写代码的时候, 我们通常更关注梯度, 所以让梯度的表达式更简洁是很有用的, 你可以通过检查梯度的范数来检查表达式, 而在代码中损失函数有时会被省略掉, 因为它只有在核验最终答案的时候才会被用到.</li></ul></li><li>在你使用梯度下降法的时候, $m$ 是很有用的. 这样你的梯度就是$m$项的平均值, 而不是他们的和, 这样在你改变数据量的时候, 梯度的数量级不会改变.<ul><li>我遇到过这样的问题: 在少量的数据上面代码运行的很好, 但是当我用整个数据集来测试的时候就出现了精度的损失, 有时候甚至会出现上/下溢, 也就是说, 梯度变成了<code>nan</code> 或者 <code>inf</code>. 只要用数据项的个数$m$来规格化数据即可</li></ul></li><li>这其中也有审美的因素在, 如果将来可能添加更多的公式, 此举可以保持"一致性", 因为这样如果将来的公式里面包含<strong>正则化</strong>的部分, 那么正则化的参数λ将不依赖于数据集大小$m$, 这样更有利于不同规格问题之间的统一.</li></ul><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/Frequentist_inference rel=noopener>https://en.wikipedia.org/wiki/Frequentist_inference</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/Bayesian_inference rel=noopener>https://en.wikipedia.org/wiki/Bayesian_inference</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/Gaussian_noise rel=noopener>https://en.wikipedia.org/wiki/Gaussian_noise</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>在高中学习的时候并没有讲解最小二乘法名字的含义, 现在看来, 可以理解成"取最小的平方误差的方法"&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p><a href=/quartz-blog/notes/2021/2021.8/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%88%86%E5%B8%83%E4%B8%8E%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E8%81%94%E7%B3%BB_Relation_of_Laplace_distribution-_and_Gaussian_distribution/ rel=noopener class=internal-link data-src=/quartz-blog/notes/2021/2021.8/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%88%86%E5%B8%83%E4%B8%8E%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E8%81%94%E7%B3%BB_Relation_of_Laplace_distribution-_and_Gaussian_distribution/>Related_Post</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/quartz-blog/notes/2021/2021.8/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%88%86%E5%B8%83%E4%B8%8E%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E8%81%94%E7%B3%BB_Relation_of_Laplace_distribution-_and_Gaussian_distribution/ data-ctx=Why_do_cost_functions_use_the_square_error data-src=/notes/2021/2021.8/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%88%86%E5%B8%83%E4%B8%8E%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E8%81%94%E7%B3%BB_Relation_of_Laplace_distribution-_and_Gaussian_distribution class=internal-link>拉普拉斯分布与高斯分布的联系_Relation_of_Laplace_distribution _and_Gaussian_distribution</a></li><li><a href=/quartz-blog/notes/2021/2021.8/Linear_RegressionGradient_Descent/ data-ctx="Regarding the $\frac1 2$ term" data-src=/notes/2021/2021.8/Linear_RegressionGradient_Descent class=internal-link>Linear_Regression&Gradient_Descent</a></li><li><a href=/quartz-blog/notes/2021/2021.8/Mean_Squared_Error_%E5%9D%87%E6%96%B9%E8%AF%AF%E5%B7%AE/ data-ctx="Regarding the frac1 2 term" data-src=/notes/2021/2021.8/Mean_Squared_Error_%E5%9D%87%E6%96%B9%E8%AF%AF%E5%B7%AE class=internal-link>Mean_Squared_Error_均方误差</a></li><li><a href=/quartz-blog/notes/2021/2021.8/Part.3_Linear_RegressionML_Andrew.Ng./ data-ctx=Why_do_cost_functions_use_the_square_error data-src=/notes/2021/2021.8/Part.3_Linear_RegressionML_Andrew.Ng. class=internal-link>Part.3_Linear_Regression(ML_Andrew.Ng.)</a></li><li><a href=/quartz-blog/notes/2021/2021.9/Part.26_Probabilistic_Interpretation_of_MSEML_Andrew.Ng./ data-ctx=Why_do_cost_functions_use_the_square_error data-src=/notes/2021/2021.9/Part.26_Probabilistic_Interpretation_of_MSEML_Andrew.Ng. class=internal-link>Part.26_Probabilistic_Interpretation_of_MSE(ML_Andrew.Ng.)</a></li><li><a href=/quartz-blog/notes/2022/2022.2/Norm-in-Regularization-Intuition/ data-ctx='L1范数约束后的解很"稀疏", 这在特征选择时是很有用的' data-src=/notes/2022/2022.2/Norm-in-Regularization-Intuition class=internal-link>Norm in Regularization - Intuition</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://alonelysheep.github.io/quartz-blog/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Cyan Fu using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2022</p><ul><li><a href=https://alonelysheep.github.io/quartz-blog/>Home</a></li><li><a href=https://github.com/ALonelySheep>Github</a></li><li><a href=https://space.bilibili.com/506700150>Bilibili</a></li></ul></footer></div></div></body></html>